# UBC CPSC 310: Introduction to Software Engineering

## This is the official course page for CPSC 310 - 2019 Winter Term 1 (all sections)

#### Note: Expect frequent updates to this page as the course progresses.

<!--
#### Please login to [here](https://github.ugrad.cs.ubc.ca/) using your CS Ugrad Id/Password by 1400 on the Friday of the first week of class; this is required so we can provision your d0 repository for you to use in lab during the second week of class.
-->

#### This is a development-heavy four-credit course. Plan your timetable accordingly. If you are not familiar with TypeScript, please start looking at it now.

## About the labs

This is a pair-programming course: If you want to work with someone specific for your project, be sure that both of you register for the _SAME_ lab section. We do not have the ability to move people around between labs; please either monitor the SSC for space in your preferred lab sections, move to another lab with space, or find a partner in the lab you are registered in. Teams **must** be firm by the time of your lab the week of the add/drop deadline. If you do not have a partner, it is your responsibility to notify the TA in lab that week so you can be paired up. If you do not have a partner at the end of your lab that week, you will not be able to complete the project (40% of your final grade). Finding a partner is **your** responsibility and is key to your having a great term, please take the time to do this right.

## Course request forms, waitlists, etc.

Unforutnately, we cannot sign course registration forms and have no knowledge or control over the class composition or waitlists. If you have any questions about registration, please contact the [CS advisors](https://www.cs.ubc.ca/students/undergrad/resources/academic-advising).

## Course learning objectives

1. **Evaluate software engineering processes** used to build modern industrial-calibre systems by justifying their benefits and tradeoffs.

1. **Elicit, deconstruct, and refine** functional requirements and quality attributes such that they are described succinctly, completely, and precisely.

1. **Devise and justify high- and low-level designs** to support a given set of requirements and in support of future evolutionary needs. 

1. **Iteratively derive implementations** of a design of reasonable complexity incorporating emergent design implications, and applying code-level restructuring for the sake of facilitating changes.

1. **Carry out the implementation** of a design incorporating ethical and security implications of code-level choices and software process and methodological approaches.

1. **Independently acquire and apply** modern and unfamiliar technology and language stacks.

1. **Validate** systems using both black-box and white-box approaches to reason about, and improve the quality of a software system.